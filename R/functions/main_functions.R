#' Read csv data
#'
#' @description Takes csv file and returns a dataframe of observed count values
#' for the country of interest
#' @param csv is the character string with the name of the csv file 
#' @param country is the character string with the name of the country
#' @return dataframe with count data and covariates

read.data <- function(csv, country){
  
  df <- read.csv(csv) %>%
    filter(Country == country) %>%
    mutate(Date = as.Date(Date)) %>%
    filter(Date < "2021-05-09")
  
}

#' Train and test split
#'
#' @description Takes data and returns a list with train and test (last 7 days of analysis)
#' for count data and covariates
#' @param df represents the data to be divided 
#' @param npi_lag is a numeric value representing the time-lag of covariates 
#' @return list of data with train and test set, divided for count data and covariates

split <- function(df, npi_lag=NULL){
  
  if(!is.null(npi_lag)){
    
    l = npi_lag
    
    lag_names <- paste("lag", formatC(l, width = nchar(max(l)), flag = "0"), 
                       sep = "_")
    lag_functions <- setNames(paste("dplyr::lag(., ", l, ")"), lag_names)
    
    data_train <- df %>% 
      slice(1:(n()-7)) %>%
      mutate(Number = as.numeric(Number)) %>%
      dplyr::select(Number) %>%
      filter(row_number() > l) %>%
      pull()
    
    xreg_train = df %>%
      slice(1:(n()-7)) %>%
      dplyr::select(!c(Date,Number,Country))  %>%
      mutate_all(funs_(lag_functions)) %>%
      dplyr::select(contains("lag"))  %>%
      filter(!is.na(.)) %>%
      mutate_all(as.numeric)
    
    df_train <- df %>% 
      slice(1:(n()-7)) %>%
      filter(row_number() > l) %>%
      dplyr::select(Date, Country) %>%
      cbind(data_train, xreg_train) %>%
      rename(Number = data_train)
    
    df_test = df %>% tail(7)
    data_test <- df_test %>% 
      mutate(Number = as.numeric(Number)) %>%
      dplyr::select(Number) %>%
      pull()
    xreg_test <- df_test %>%
      dplyr::select(starts_with(c("c", "h"))) %>%
      dplyr::select(!Country) %>%
      mutate_all(as.numeric)
    
    colnames(df_test) <- c("Country", "Date","Number",colnames(xreg_train))
    colnames(xreg_test) <- colnames(xreg_train)
    
  } else{
    
    df_train = df %>% slice(1:(n()-7))
    data_train <- df_train %>% 
      mutate(Number = as.numeric(Number)) %>%
      dplyr::select(Number) %>%
      pull()
    xreg_train <- df_train %>%
      dplyr::select(starts_with(c("c", "h"))) %>%
      dplyr::select(!Country) %>%
      mutate_all(as.numeric)
    
    df_test = df %>% tail(7)
    
    data_test <- df_test %>% 
      mutate(Number = as.numeric(Number)) %>%
      dplyr::select(Number) %>%
      pull()
    xreg_test <- df_test %>%
      dplyr::select(starts_with(c("c", "h"))) %>%
      dplyr::select(!Country) %>%
      mutate_all(as.numeric)
  }
  return(out <- list(train=list(df_train = df_train,
                                data_train = data_train,
                                xreg_train = xreg_train),
                     test=list(df_test = df_test,
                               data_test = data_test,
                               xreg_test = xreg_test)))
}

#' Summary of model fit
#'
#' @description Takes the output from model functions in `BAYES_log.R` or `tvBAYES_log.R` 
#' and generates a list of elements with summary of posterior coefficients, fitted values and 
#' error metrics
#' @param fit is a list of posterior estimates as generated by model functions in `BAYES_log.R` 
#' or `tvBAYES_log.R`  
#' @param data_list is a list of train and test data (count data and covariates) 
#' as returned from `split` function 
#' @param model is a list containing the specification of model order, logical wheter 
#' to assume or not time-varying coefficients (tv = TRUE or tv = FALSE) and the specification
#' of b-splines' knots
#' @param link represent a character string giving the link function
#' @param distr represents a character string giving the conditional distribution
#' @param xreg is a logical value indicating whether covariates should be included or not
#' while computing model summary
#' @param country is a character string with country name
#' @return list object with summary of posterior coefficients, fitted values and 
#' error metrics

bayes.posterior <- function(fit, data_list, model = list(past_obs = 1, past_mean = NULL, tv = FALSE, knot = NULL), 
                            link = "log", distr = "poisson", xreg = TRUE, 
                            country = "Italy"){
  options(warn=-1)
  df_train = data_list[["train"]][["df_train"]]
  df_test = data_list[["test"]][["df_test"]]
  data_train = data_list[["train"]][["data_train"]]
  xreg_train = data_list[["train"]][["xreg_train"]]
  
  if (model[["tv"]] == FALSE){
    if (is.null(model[["past_mean"]])){
      if (xreg == FALSE){
        
        # Summary of posterior distribution
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        # Posterior coefficient estimates
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=0))
        
        At <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                          data = data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        coeff_list <- list(mut=mut, At=At)
        
        # Summary of coefficient estimates
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        sum_fit = list()
        for (j in delta){
          sum <- summary.fit.tc(fit, j)
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = names(coeff_list)
        tot_desc$Parameter = names(coeff_list)
        
        # In-sample predictions
        
        vt <- predict(data=data_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country, data = data_train, link=link))
        )
        
      } else if (xreg == TRUE){
        
        # Summary of posterior distribution
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        # Posterior coefficient estimates
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=0))
        
        At <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                          data = data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        Ct <- coeff_Ct(summary=p_summary[["deltaCfn"]],
                       data=data_train, xreg=xreg_train, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        coeff_list <- list(mut=mut, At=At, Ct=Ct)
        
        # Summary of coefficient estimates
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        sum_fit = list()
        for (j in delta){
          if (j == "deltaCfn"){
            sum <- summary.fit.tc(fit, j, cov_names = colnames(xreg_train))
          } else{
            sum <- summary.fit.tc(fit, j)
          }
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c(names(coeff_list)[1:2], colnames(xreg_train))
        tot_desc$Parameter = c(names(coeff_list)[1:2], colnames(xreg_train))
        
        # In-sample predictions
        
        vt <- predict(data=data_train, xreg = xreg_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country, data = data_train, xreg=xreg_train, link=link))
        )
        
      }
    } else if (!is.null(model[["past_mean"]])){
      if(xreg == FALSE){
        
        for (i in 1:length(fit[["deltaRfn"]])){
          deltaRfn <- unlist(fit[["deltaRfn"]][[i]])
          deltaKfn <- unlist(fit[["deltaKfn"]][[i]])
          fit[["deltaRfn"]][[i]] <- (deltaRfn+deltaKfn)/2
          fit[["deltaKfn"]][[i]] <- (deltaRfn-deltaKfn)/2
        }
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=model[["past_mean"]]))
        
        At_Bt <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                             summary_K = p_summary[["deltaKfn"]],
                             data = data_train, order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]))
        
        coeff_list <- list(sigma2lat=p_summary[["sigma2latfn"]], 
                           mut=mut, At = At_Bt[["At"]], Bt=At_Bt[["Bt"]])
        
        # Summary of coefficient estimates
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        sum_fit = list()
        for (j in delta){
          sum <- summary.fit.tc(fit, j)
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c("mut", "sigma2lat", "At", "Bt")
        tot_desc$Parameter = c("mut", "sigma2lat", "At", "Bt")
        
        vt <- predict(data=data_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = 1, order2 = 1))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country, data = data_train, link=link))
        )
        
      } else if(xreg == TRUE){
        
        for (i in 1:length(fit[["deltaRfn"]])){
          deltaRfn <- unlist(fit[["deltaRfn"]][[i]])
          deltaKfn <- unlist(fit[["deltaKfn"]][[i]])
          fit[["deltaRfn"]][[i]] <- (deltaRfn+deltaKfn)/2
          fit[["deltaKfn"]][[i]] <- (deltaRfn-deltaKfn)/2
        }
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order = list(order1=model[["past_obs"]], order2=model[["past_mean"]]))
        
        At_Bt <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                             summary_K = p_summary[["deltaKfn"]],
                             data = data_train, order = list(order1 =model[["past_obs"]], order2 = model[["past_mean"]]))
        
        Ct <- coeff_Ct(summary=p_summary[["deltaCfn"]],
                       data=data_train, xreg=xreg_train, order = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]))
        
        coeff_list <- list(sigma2lat=p_summary[["sigma2latfn"]], 
                           mut=mut, At = At_Bt[["At"]], Bt=At_Bt[["Bt"]], Ct=Ct)
        
        # Summary of coefficient estimates
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        sum_fit = list()
        for (j in delta){
          if (j == "deltaCfn"){
            sum <- summary.fit.tc(fit, j, cov_names = colnames(xreg_train))
          } else{
            sum <- summary.fit.tc(fit, j)
          }
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c("mut", "sigma2lat", "At", "Bt", colnames(xreg_train))
        tot_desc$Parameter = c("mut", "sigma2lat", "At", "Bt", colnames(xreg_train))
        
        # Predictions 
        
        vt <- predict(data=data_train, xreg=xreg_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = 1, order2 = 1))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model,country=country, data = data_train, xreg=xreg_train, link=link))
        )
        
      } 
    }
  } else if(model[["tv"]] == TRUE){
    if (is.null(model[["past_mean"]])){
      if (xreg == FALSE){
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        bsplines <- bsplines_fun(data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 knot = model[["knot"]], norder = 4)
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=0),
                         bsplines_list =list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        At <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                          data = data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0), 
                          bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        coeff_list <- list(mut=mut, At=At)
        
        post_coeff<- names(coeff_list)
        sum_fit = list()
        for (j in post_coeff){
          coeff = coeff_list[[j]]
          sum <- summary.fit.tv(coeff)
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = names(coeff_list)
        tot_sum <- tot_sum %>%
          dplyr::select(Parameter, everything())
        tot_desc$Parameter = names(coeff_list)
        
        
        vt <- predict(data=data_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model,country=country, data = data_train, link=link))
        )
        
      } else if (xreg == TRUE){
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        bsplines <- bsplines_fun(data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 knot = model[["knot"]], norder = 4)
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=0),
                         bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        At <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                          data = data_train, order_list = list(order1 = model[["past_obs"]], order2 = 0), 
                          bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        Ct <- coeff_Ct(summary=p_summary[["deltaCfn"]],
                       data=data_train, xreg=xreg_train, order_list = list(order1 = model[["past_obs"]], order2 = 0),
                       bsplines_list = list(bsplines=bsplines, knot=model[["knot"]], norder=4))
        
        coeff_list <- list(mut=mut, At=At, Ct=Ct)
        
        post_coeff<- names(coeff_list)
        sum_fit = list()
        for (j in post_coeff){
          coeff = coeff_list[[j]]
          if(j == "Ct"){
            names <- names(coeff)
            for(i in names){
              cov <- coeff_list[["Ct"]][[i]]
              sum <- summary.fit.tv(cov)
              sum_fit[[i]] <- sum
            }
          }else{
            sum <- summary.fit.tv(coeff)
            sum_fit[[j]] <- sum
          }
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c(names(coeff_list)[1:2], colnames(xreg_train))
        tot_sum <- tot_sum %>%
          dplyr::select(Parameter, everything())
        tot_desc$Parameter = c(names(coeff_list)[1:2], colnames(xreg_train))
        
        vt <- predict(data=data_train, xreg = xreg_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = model[["past_obs"]], order2 = 0))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country,data = data_train, xreg=xreg_train, link=link))
        )
        
      }
    } else if (!is.null(model[["past_mean"]])){
      if(xreg == FALSE){
        
        for (i in 1:length(fit[["deltaRfn"]])){
          deltaRfn <- unlist(fit[["deltaRfn"]][[i]])
          deltaKfn <- unlist(fit[["deltaKfn"]][[i]])
          fit[["deltaRfn"]][[i]] <- (deltaRfn+deltaKfn)/2
          fit[["deltaKfn"]][[i]] <- (deltaRfn-deltaKfn)/2
        }
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        bsplines <- bsplines_fun(data_train, order_list = list(order1 =model[["past_obs"]], order2 = model[["past_mean"]]),
                                 knot = model[["knot"]], norder = 4)
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order_list = list(order1=model[["past_obs"]], order2=model[["past_mean"]]),
                         bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        At_Bt <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                             summary_K = p_summary[["deltaKfn"]],
                             data = data_train, order_list = list(order1 = model[["past_obs"]], order2 =model[["past_mean"]]), 
                             bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        coeff_list <- list(sigma2lat=p_summary[["sigma2latfn"]], 
                           mut=mut, At = At_Bt[["At"]], Bt=At_Bt[["Bt"]])
        
        post_coeff<- names(coeff_list)
        sum_fit = list()
        for (j in post_coeff){
          coeff = coeff_list[[j]]
          sum <- summary.fit.tv(coeff)
          sum_fit[[j]] <- sum
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c("sigma2lat", "mut",  "At", "Bt")
        tot_sum <- tot_sum %>%
          dplyr::select(Parameter, everything())
        tot_desc$Parameter = c("sigma2lat", "mut", "At", "Bt")
        
        vt <- predict(data=data_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, 
                      order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country,data = data_train, link=link))
        )
        
      } else if(xreg == TRUE){
        
        for (i in 1:length(fit[["deltaRfn"]])){
          deltaRfn <- unlist(fit[["deltaRfn"]][[i]])
          deltaKfn <- unlist(fit[["deltaKfn"]][[i]])
          fit[["deltaRfn"]][[i]] <- (deltaRfn+deltaKfn)/2
          fit[["deltaKfn"]][[i]] <- (deltaRfn-deltaKfn)/2
        }
        
        delta <- names(fit)[names(fit) != "pred" & names(fit) != "vtp"]
        p_summary = list()
        for (j in delta){
          sum <- summary(fit, j)
          p_summary[[j]] <- sum
        }
        
        bsplines <- bsplines_fun(data_train, order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 knot = model[["knot"]], norder = 4)
        
        mut <- coeff_mut(summary=p_summary[["deltamufn"]], 
                         data= data_train, order = list(order1=model[["past_obs"]], order2=model[["past_mean"]]),
                         bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        At_Bt <- coeff_At_Bt(summary_R = p_summary[["deltaRfn"]], 
                             summary_K = p_summary[["deltaKfn"]],
                             data = data_train, order = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]), 
                             bsplines_list = list(bsplines=bsplines, knot = model[["knot"]], norder=4))
        
        Ct <- coeff_Ct(summary=p_summary[["deltaCfn"]],
                       data=data_train, xreg=xreg_train, order = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                       bsplines_list = list(bsplines=bsplines, knot=model[["knot"]], norder=4))
        
        coeff_list <- list(sigma2lat=p_summary[["sigma2latfn"]], 
                           mut=mut, At = At_Bt[["At"]], Bt=At_Bt[["Bt"]], Ct=Ct)
        
        post_coeff<- names(coeff_list)
        sum_fit = list()
        for (j in post_coeff){
          coeff = coeff_list[[j]]
          if(j == "Ct"){
            names <- names(coeff)
            for(i in names){
              cov <- coeff_list[["Ct"]][[i]]
              sum <- summary.fit.tv(cov)
              sum_fit[[i]] <- sum
            }
          }else{
            sum <- summary.fit.tv(coeff)
            sum_fit[[j]] <- sum
          }
        }
        
        tot_sum = data.frame()
        tot_desc = data.frame()
        for (i in names(sum_fit)){
          sum <- sum_fit[[i]][["summary"]]
          tot_sum <- tot_sum %>%
            rbind(sum)
          
          desc <- sum_fit[[i]][["desc_post"]]
          tot_desc <- tot_desc %>%
            rbind(desc)
        }
        
        tot_sum$Parameter = c("sigma2lat","mut",  "At", "Bt", colnames(xreg_train))
        tot_sum <- tot_sum %>%
          dplyr::select(Parameter, everything())
        tot_desc$Parameter = c("sigma2lat","mut",  "At", "Bt", colnames(xreg_train))
        
        # Predictions 
        
        vt <- predict(data=data_train, xreg=xreg_train, date = df_train %>% dplyr::select(Date),
                      coeff_list=coeff_list, order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]))
        
        metrics_train <- pred_eval(y_pred = vt$Mean, y_true = data_train[-1])
        
        result <- c(
          list(hmc.parameters = p_summary, 
               coefficients=list(coefficient.distribution= coeff_list,
                                 coefficient.summary = list(summary=tot_sum, pd = tot_desc)),
               fitted.values=vt, 
               linear.predictors= vt %>% mutate_if(is.numeric, log),
               error.metrics = metrics_train, 
               model=list(model=model, country=country,data = data_train, xreg=xreg_train, link=link))
        )
        
      } 
    }
    
  }
  
  return(result)
}

#' Summary of model predictions
#'
#' @description Takes the output from model functions in `BAYES_log.R` or `tvBAYES_log.R` 
#' and generates a list of elements with summary of model predictions over test set
#' (if validation = TRUE) or n-ahead forecast (if validation = FALSE) and
#' error metrics
#' @param fit is a list of posterior estimates as generated model functions in `BAYES_log.R` 
#' or `tvBAYES_log.R`  
#' @param data_list is a list of train and test data (count data and covariates) 
#' as returned from `split` function 
#' @param model is a list containing the specification of model order, logical wheter 
#' to assume or not time-varying coefficients (tv = TRUE or tv = FALSE) and the specification
#' of b-splines' knots
#' @param coeff_list is the list of posterior coefficients
#' @param n.ahead is a positive integer value giving the number of steps ahead for which 
#' predictions should be made
#' @param validation logical value specifying whether predictions will be validated
#' on a test set (validation = TRUE) or not (validation = FALSE)
#' @param xreg xreg is a logical value indicating whether covariates should be included or not
#' while computing model summary
#' @param country is a character string with country name
#' @return list of elements with summary of model predictions and error metrics

bayes.predict <- function(fit, data_list, model = list(past_obs = 1, past_mean = NULL, tv = FALSE), 
                          coeff_list =  NULL, n.ahead = 1, validation = TRUE,
                          xreg = TRUE, country = "Italy"){
  
  df_train = data_list[["train"]][["df_train"]]
  data_train = data_list[["train"]][["data_train"]]
  xreg_train = data_list[["train"]][["xreg_train"]]
  if (validation == TRUE){
    df_test = data_list[["test"]][["df_test"]]
    data_test = data_list[["test"]][["data_test"]]
    xreg_test = data_list[["test"]][["xreg_test"]]
  }
  
  if (model[["tv"]] == FALSE){
    if (is.null(model[["past_mean"]])){
      if (xreg == FALSE){
        
        if (validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="AR", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
        
      } else if (xreg == TRUE){
        
        if (validation == TRUE){
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 xreg_train = xreg_train, newxreg = xreg_test, coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 validation = TRUE, n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="ARX", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test, xreg = xreg_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 xreg_train = xreg_train, coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 validation = FALSE, n.ahead=n.ahead)
          
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
        
      }
    } else if (!is.null(model[["past_mean"]])){
      if(xreg == FALSE){
        
        if (validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="INGARCH", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
        
      } else if(xreg == TRUE){
        
        if (validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, xreg_train =xreg_train, newxreg = xreg_test, 
                                 date = df_train %>% pull(Date), coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 =model[["past_mean"]]),
                                 validation = TRUE, n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="INGARCHX", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test, xreg = xreg_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, xreg_train =xreg_train, 
                                 date = df_train %>% pull(Date), coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 =model[["past_mean"]]),
                                 validation = FALSE, n.ahead=n.ahead)
          
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
      } 
    }
  } else if(model[["tv"]] == TRUE){
    if (is.null(model[["past_mean"]])){
      if (xreg == FALSE){
        
        if (validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="tvAR", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test))
          )
        } else if(validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
        
      } else if (xreg == TRUE){
        
        if (validation == TRUE){
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 xreg_train = xreg_train, newxreg = xreg_test, coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="tvARX", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test, xreg = xreg_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 xreg_train = xreg_train, coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = 0),
                                 n.ahead=n.ahead)
          
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
        
      }
    } else if (!is.null(model[["past_mean"]])){
      if(xreg == FALSE){
        
        if (validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="tvINGARCH", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, date = df_train %>% pull(Date), 
                                 coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
          
        }
      } else if(xreg == TRUE){
        
        if(validation == TRUE){
          
          fcst <- forecast_ahead(data=data_train, xreg_train =xreg_train, newxreg=xreg_test, 
                                 date = df_train %>% pull(Date), coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          
          metrics_test <- pred_eval(y_pred = fcst$Mean, y_true = data_test)
          
          fcst_long <- fcst_long_format(point_est = "Mean", fcst=fcst, country = country, 
                                        model="tvINGARCHX", truth_data = df_test)
          
          metrics_test_scoring <- eval_fcst(fcst_long, summarise_by = c("target_variable", "model"),
                                            model_comp = FALSE)
          
          result <- c(
            list(pred = fcst, 
                 pred_long = fcst_long,
                 ML.error.metrics=metrics_test,
                 scoringutils.error.metrics=metrics_test_scoring,
                 model=list(model=model, country=country, data = data_test, xreg = xreg_test))
          )
        } else if (validation == FALSE){
          
          fcst <- forecast_ahead(data=data_train, xreg_train =xreg_train, 
                                 date = df_train %>% pull(Date), coeff_list=coeff_list, 
                                 order_list = list(order1 = model[["past_obs"]], order2 = model[["past_mean"]]),
                                 n.ahead=n.ahead)
          result <- c(
            list(pred = fcst, 
                 model=list(model=model, country=country))
          )
        }
      }
    } 
  }
  return(result)
}

