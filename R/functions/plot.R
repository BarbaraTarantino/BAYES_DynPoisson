#' Traceplot
#'
#' @description Takes the output from model functions in `BAYES_log.R` or `tvBAYES_log.R` 
#' and generates trace plots for MCMC output analysis according to this formula 
#' $\frac{1}{T}\left[\sum_{j=1}^{T}\overline{(\mu(j/T)^t-\mu(j/T)^{t+1})^2}\right]^{1/2}$
#' @param object is a list of posterior estimates as generated by model functions 
#' in `BAYES_log.R` or `tvBAYES_log.R`  
#' @param delta represents the name of the parameter of interest in the previous list `object`.
#' (`deltamufn` for intercept, `deltaRfn` for autoregressive parameter, `deltaKfn` for
#' parameter wrt dependence on conditional mean, `deltaCfn` for covariates)
#' @param thin is a numeric value that determines the thinning intervall of the chain
#' @param tv logical, whether the model includes or not time-varying coefficients
#' @return plot object for MCMC output analysis

traceplot <- function(object, delta, thin = 0, tv = "FALSE"){
  
  # Get delta
  if (class(delta) != "character"){
    stop("Delta needs to be of character type!")
  }
  par <- object[[delta]]
  chain  <- matrix(unlist(par), length(par[[1]]))
  
  # Thin
  if (thin > 0){
    colnum <- ncol(chain)
    thin <- abs(round(thin))
    if(thin > colnum) stop("Thin exceeds number of MCMC samples.")
    keepcols <- which(rep(1:thin, len=colnum) == thin)
    chain <- t(chain[,keepcols])
  }
  
  # Traceplot
  if (tv == "FALSE"){
    if(delta == "sigma2latfn" | delta == "pred" ){
      n = ncol(chain)
      return(plot(chain[2:n] - chain[1:(n-1)])^2)
    } else{
      n = ncol(chain)
      return(plot(chain[, 2:n] - chain[, 1:(n-1)])^2)
    }} else if (tv == "TRUE"){
      if(delta == "sigma2latfn" | delta == "pred"){
        n = ncol(chain)
        return(plot(chain[2:n] - chain[1:(n-1)])^2)
      } else{
        n = ncol(chain)
        return(plot(colMeans((chain[, 2:n] - chain[, 1:(n-1)])^2)))
      }}
  
}

#' Plot Predictions vs True Values (daily frequency)
#'
#' @description Make a plot of observed and predicted values with daily frequency
#' @param point_est represents the point estimate to summarise predictive distribution
#' @param fcst is the dataframe of predictions
#' @param country is the character value with the name of the country of interest
#' @param model represents the character value specifying model of interest
#' @param truth_data is the dataframe of true data
#' @return ggplot object with a plot of true vs predicted values

fcst_plot <- function(point_est = "Mean", fcst, country, model, truth_data){
  
  fcst_tot = c()
  for (i in 1:nrow(fcst)){
    
    fcst_2 <- fcst %>%
      slice(i) %>%
      dplyr::select(all_of(point_est), starts_with("Quantile")) %>%
      gather() %>%
      mutate(quantile = extract_numeric(key),
             key = ifelse(key == "Mean", "point", key),
             key = ifelse(str_detect(key, "Quantile"), "quantile", key),
             horizon = i,
             temporal_resolution = "day", 
             target_end_date = fcst$forecast_date[i]) %>%
      rename(type = key) %>%
      dplyr::select(quantile, value, type, horizon, temporal_resolution, target_end_date) 
    
    fcst_tot <- fcst_tot %>%
      rbind(fcst_2)
  }
  
  fcst_tot <- fcst_tot %>%
    mutate(forecast_date = fcst$forecast_date[1]-1,
           location = country, 
           target_variable = "inc cases", 
           model = model) %>%
    rename(prediction = value) %>%
    dplyr::select(model, forecast_date, target_variable, 
                  target_end_date, location, quantile, 
                  prediction, type)
  
  truth_data <- truth_data %>%
    dplyr::select(Country, Date,Number) %>%
    mutate(Date = as.Date(Date),
           Number = as.numeric(Number)) %>%
    rename(target_end_date = Date,
           location = Country,
           true_value = Number) %>%
    mutate(target_variable = unique(fcst_tot$target_variable)) %>%
    dplyr::select(target_end_date, true_value, 
                  target_variable, location)
  
  data_plot <- truth_data %>%
    dplyr::bind_rows(fcst_tot) %>%
    filter(target_end_date > "2021-02-28")
  
  plot <- scoringutils::plot_predictions(data_plot,
                                         x = "target_end_date",
                                         facet_formula = ~ model,
                                         ncol = 3,
                                         # facet_formula = model ~ target_variable + loc,
                                         # facet_wrap_or_grid = "facet",
                                         allow_truth_without_pred = FALSE,
                                         scales = "free") + 
    # ggplot2::ggtitle(paste0("Predictions for incident ", target_variable,  "s")) + 
    ggplot2::theme(legend.position = "bottom", 
                   strip.placement = "outside") + 
    scale_y_continuous(labels = scales::comma) + 
    expand_limits(y = 0) + 
    coord_cartesian(ylim = c(0, NA))
  
  return(print(plot))
}

#' Summary of contribution from model components
#'
#' @description Make a summary of contribution from model components
#' @param data represents count data used in model fit
#' @param xreg is the dataframe containing values for covarates used in model fit
#' @param coeff_list is the list of posterior coefficients
#' @param order_list is a list of the specification of model order (p,q)
#' @return dataframe with summary of contribution from model components

post_contribution <- function(data, xreg = NULL, coeff_list,
                                   order_list = list(order1 = 1, order2 = 0)){
  
  if (order_list[["order2"]] != 0){
    order1 = order_list[["order1"]]
    order2 = order_list[["order2"]]
    order = max(order1, order2)
    
    Y <- data 
    if(order>0){Y <- data[-(1:order)]}
    X <- NULL
    if(order > 0){
      for(j in 1:order){
        ind <- (order-j+1):(length(data) - j)
        X <- cbind(X, array(data[ind]))
      } 
    }
    
    xreg <- xreg[-(1:order),]
    n <- ncol(xreg)
    
    temp <- as.numeric(as.data.frame(coeff_list[["sigma2lat"]][["Mean"]]))
    mut <- as.data.frame(coeff_list[["mut"]][["Mean"]])
    At <- as.data.frame(coeff_list[["At"]][["Mean"]])
    Bt <- as.data.frame(coeff_list[["Bt"]][["Mean"]])
    Ct_mat <- coeff_list[["Ct"]]
    Ct = matrix(0, nrow = length(data)-order, ncol = ncol(xreg))
    for(k in 1:n){
      Ct[,k] <- Ct_mat[[paste0("Ct", k)]][["Mean"]]
    }
    Ct <- as.data.frame(Ct)
    
    Int <-c(); AR <- c()
    MA <- c(); XREG = matrix(0, nrow = length(data)-order, ncol = ncol(xreg))
    
    vt = matrix(0, nrow=length(data)-order)
    for (j in 1:(length(data)-order)){
      vt[j] <- mut[j,] + sum(At[j,]*log1p(X[j,]))+ sum(Bt[j,]*temp[(order2+j-1):j])+ sum(Ct[j,]*xreg[j,])
      temp   <- c(temp, vt[j])
      Int[j] <- mut[j,]
      AR[j] <- sum(At[j, ]*log1p(X[j, ]))
      MA[j] <- sum(Bt[j, ]*temp[(order2+j-1):j])
      for (k in 1:n){
        XREG[j,k] <- array(Ct[j,k] * xreg[j,k])
      }
    }
    
    comp <- data.frame(Int, AR, MA, XREG)
    
    data_long <- comp %>%
      dplyr::select(!c(Int))  %>%
      summarise_all(mean) %>%
      gather(variable, value) 
    
  } else{
    
    order = order_list[["order1"]]
    Y <- data 
    if(order>0){Y <- data[-(1:order)]}
    X <- NULL
    if(order > 0){
      for(j in 1:order){
        ind <- (order-j+1):(length(data) - j)
        X <- cbind(X, array(data[ind]))
      } 
    }
    
    xreg <- xreg[-(1:order),]
    n <- ncol(xreg)
    
    mut <- as.data.frame(coeff_list[["mut"]][["Mean"]])
    At <- as.data.frame(coeff_list[["At"]][["Mean"]])
    
    Ct_mat <- coeff_list[["Ct"]]
    Ct = matrix(0, nrow = length(data)-order, ncol = ncol(xreg))
    for(k in 1:n){
      Ct[,k] <- Ct_mat[[paste0("Ct", k)]][["Mean"]]
    }
    # Ct <- as.data.frame(Ct)
    
    AR = array(At * log1p(X))
    XREG = matrix(0, nrow = length(data)-order, ncol = ncol(xreg))
    for (k in 1:n){
      XREG[,k] <- array(Ct[,k] * xreg[,k])
    }
    colnames(XREG) <- colnames(xreg)
    
    comp2 = (array(At * log1p(X)))
    comp3 <- array(rowSums(Ct * xreg))
    vt_mat <- array(unlist(mut)) + array(unlist(comp2)) + array(comp3)
    
    comp <- data.frame(mut, AR, XREG)
    
    data_long <- comp %>%
      dplyr::select(!c("coeff_list...mut......Mean...")) %>%
      summarise_all(mean) %>%
      gather(variable, value) 
    
  }
  
  return(plot.contribution.summary(data_long))
}

#' Plot of contribution from model components
#'
#' @description Make a ggplot object of contribution from model components
#' @param data_long represents long dataframe with contribution from model 
#' components as returned from `post_contribution`
#' @return ggplot object with a plot of contribution from model components

plot.contribution.summary <- function(data_long){
  x_bound <- max(abs(data_long$value))
  require('ggforce') # for `geom_sina`
  plot1 <- ggplot(data = data_long, aes(x = variable, y = value))+
    coord_flip() + 
    # sina plot: 
    geom_bar(stat="identity", aes(fill = value)) +
    # print the mean absolute value: 
    geom_text(data = unique(data_long[, c("variable", "value")]),
              aes(x = variable, y=-Inf, label = sprintf("%.3f", value)),
              size = 3, alpha = 0.7,
              hjust = -0.2, 
              fontface = "bold") + # bold
    # # add a "SHAP" bar notation
    # annotate("text", x = -Inf, y = -Inf, vjust = -0.2, hjust = 0, size = 3,
    #          label = expression(group("|", bar(SHAP), "|"))) + 
    scale_fill_gradient(low="#FFCC33", high="#6600CC", 
                        breaks=c(0.8,3.5), labels = NULL) + #labels=c("Negative","Positive")
    theme_bw() + 
    theme(axis.line.y = element_blank(), axis.ticks.y = element_blank(), # remove axis line
          legend.position="bottom") + 
    # geom_hline(yintercept = 0) + # the vertical line
    scale_y_continuous(limits = c(-x_bound, x_bound)) +
    # reverse the order of features
    scale_x_discrete(limits = rev(levels(data_long$variable)) 
    ) + 
    labs(y = "Posterior contribution (average impact on model output)", x = "", color = "Feature value") 
  return(plot1)
}

#' Plot Predictions vs True Values (over train and test horizon, with daily frequency)
#'
#' @description Make a plot of observed and predicted values with daily frequency
#' @param fit_post represents the summary of model fit as returned from `bayes.posterior`
#' function
#' @param fit_pred represents the summary of model predictions as returned from 
#' `bayes.predict` function
#' @param data_list is a list of train and test data (count data and covariates) 
#' as returned from `split` function 
#' @param country is the character value with the name of the country of interest
#' @param model represents the character value specifying model of interest
#' @return ggplot object with a plot of true vs predicted values

plot.pred.fcst <- function(fit_post, fit_pred, data_list, country, model){

  fcst_train <- fit_post[["fitted.values"]]
  fcst_train <- fcst_train %>%
  rename(forecast_date = Date)
  fcst_long_train <- fcst_long_format(point_est = "Mean", fcst=fcst_train, country, model,
                                    truth_data = data_list[["train"]][["df_train"]])

  pred = fit_pred[["pred_long"]]
  pred = pred %>% mutate(true_value = NA)
  
  data_plot <- fcst_long_train %>% rbind(pred)

  plot <- scoringutils::plot_predictions(data_plot,
                                       x = "target_end_date",
                                       facet_formula = ~ model,
                                       ncol = 3,
                                       # facet_formula = model ~ target_variable + loc,
                                       # facet_wrap_or_grid = "facet",
                                       allow_truth_without_pred = FALSE,
                                       scales = "free") + 
  # ggplot2::ggtitle(paste0("Predictions for incident ", target_variable,  "s")) + 
  ggplot2::theme(legend.position = "bottom", 
                 strip.placement = "outside") + 
  scale_y_continuous(labels = scales::comma) + 
  expand_limits(y = 0) + 
  coord_cartesian(ylim = c(0, NA))

  library(wesanderson)
  
  plot <- plot +
    geom_vline(xintercept = as.numeric(as.Date("2021-05-01")), linetype=4) +
    scale_fill_manual(values=wes_palette(n=3, name="GrandBudapest2")) +
    scale_color_manual(values=c("gray40",wes_palette(name="GrandBudapest2"))) +
    theme(axis.title.x = element_blank())
  
  return(plot)
}

#' Plot Predictions vs True Values (with weekly frequency, i.e. by epidemiological weeks)
#'
#' @description Make a plot of observed and predicted values with daily frequency
#' @param point_est represents the point estimate to summarise predictive distribution
#' @param fcst is the dataframe of predictions
#' @param country is the character value with the name of the country of interest
#' @param model represents the character value specifying model of interest
#' @param truth_data is the dataframe of true data
#' @return ggplot object with a plot of true vs predicted values

pred.plot <- function(point_est="Mean", fcst, country, 
                      model, truth_data){
  
  fcst_tot = c()
  for (i in 1:nrow(fcst)){
    
    fcst_2 <- fcst %>%
      slice(i) %>%
      dplyr::select(all_of(point_est), starts_with("Quantile")) %>%
      gather() %>%
      mutate(quantile = extract_numeric(key),
             key = ifelse(key == "Mean", "point", key),
             key = ifelse(str_detect(key, "Quantile"), "quantile", key),
             horizon = i,
             temporal_resolution = "day", 
             target_end_date = fcst$forecast_date[i]) %>%
      rename(type = key) %>%
      dplyr::select(quantile, value, type, horizon, temporal_resolution, target_end_date) 
    
    fcst_tot <- fcst_tot %>%
      rbind(fcst_2)
  }
  
  fcst_tot <- fcst_tot %>%
    mutate(epi_week = epiweek(target_end_date), 
           week_day = weekdays(target_end_date))
  
  hub <- fcst_tot %>%
    group_by(quantile, epi_week) %>%
    summarise(value = sum(value)) %>%
    ungroup()
  
  week <- fcst_tot %>%
    filter(week_day == "Saturday") %>%
    dplyr::select(target_end_date, epi_week) %>%
    distinct(epi_week, target_end_date)
  
  hub <- plyr::join(hub, week, by = "epi_week")
  
  hub <- hub %>%
    mutate(type = ifelse(is.na(quantile), "point", "quantile"))
  
  report_date <- fcst %>%
    dplyr::select(forecast_date) %>%
    mutate(day = weekdays(forecast_date)) %>%
    filter(day == "Monday") %>%
    filter(row_number() == 1) %>%
    pull(forecast_date)
  
  library(countrycode)
  location_code = countrycode(country, origin = 'country.name', destination = 'iso2c')
  
  hub <- hub %>%
    mutate(forecast_date = report_date,
           week_ahd = seplyr::add_group_indices(., c("target_end_date"), "group_ID")$group_ID,
           target = paste(week_ahd, "wk ahead inc case"),
           location = location_code, 
           scenario_id = "forecast") %>%
    dplyr::select(forecast_date, target, target_end_date, location, quantile, value,
                  type, scenario_id) 
  
  truth_data <- truth_data %>%
    dplyr::select(Country, Date,Number) %>%
    mutate(Date = as.Date(Date),
           Number = as.numeric(Number)) %>%
    rename(target_end_date = Date,
           true_value = Number, 
           location = Country) %>%
    dplyr::select(target_end_date, true_value, location) %>%
    filter(target_end_date > "2021-02-28") 
  
  truth_data <- truth_data %>%
    mutate(epi_week = epiweek(target_end_date), 
           week_day = weekdays(target_end_date))
  
  truth_hub <-truth_data %>%
    group_by(epi_week) %>%
    summarise(true_value = sum(true_value)) %>%
    ungroup()
  
  truth_week <-truth_data %>%
    filter(week_day == "Saturday") %>%
    dplyr::select(target_end_date, epi_week) %>%
    distinct(epi_week, target_end_date)
  
  truth_hub <- plyr::join(truth_hub, truth_week, by = "epi_week")
  
  truth_hub <- truth_hub %>%
    dplyr::select(!epi_week)
  
  hub <- hub %>% rename(prediction = value)
  
  data_plot <- truth_hub %>%
    dplyr::bind_rows(hub) %>%
    filter(target_end_date > "2021-02-28") %>%
    mutate(model = model)
  
  # tiff("IT.tiff", units="in", width=5, height=5, res=300)
  plot <- scoringutils::plot_predictions(data_plot,
                                         x = "target_end_date",
                                         facet_formula = ~ model,
                                         ncol = 3,
                                         # facet_formula = model ~ target_variable + loc,
                                         # facet_wrap_or_grid = "facet",
                                         allow_truth_without_pred = FALSE,
                                         scales = "free") + 
    # ggplot2::ggtitle(paste0("Predictions for incident ", target_variable,  "s")) + 
    ggplot2::theme(legend.position = "bottom", 
                   strip.placement = "outside") + 
    scale_y_continuous(labels = scales::comma) + 
    expand_limits(y = 0) + 
    coord_cartesian(ylim = c(0, NA))
  
  return(plot)
  
  
}

#' Plot median time-varying coefficient estimates with 95% time-interval
#'
#' @description Make a plot of observed and predicted values with daily frequency
#' @param pd is a dataframe with median point-estimate, 95% interval over time period
#' and probability of direction over the horizon. 
#' @return ggplot object with a plot of median time-varying coefficient estimates

pd.plot <- function(pd){
  
  pd_plot <- ggplot(data = pd, 
                    aes(x = Median, y = Parameter)) + 
    ggstance::geom_pointrangeh(
      aes(y = Parameter,x = Median,, xmin = Min,
          xmax = Max, colour = Lag, shape = Model),
      position = ggstance::position_dodgev(height = 0.5),
      fill = "white", fatten = 4, size = 0.8) +
    # geom_point(size = 2) + 
    scale_color_manual(values=wes_palette(name="GrandBudapest2")) +
    ylab("") +
    ggplot2::theme_light()+
    theme(text = element_text(size = 15)) +
    facet_grid( Parameter ~ Model, 
                scales="free", switch = 'y') +
    theme(axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank()) +
    geom_vline(xintercept = 0, linetype="dashed", colour = "grey") +
    guides(shape  = guide_legend(order = 1),
           colour = guide_legend(order = 2))
  
  return(pd_plot)
}

#' @title Plot Contributions to the Weighted Interval Score in train and test set
#'
#' @description Visualise the components of the weighted interval score: penalties for
#' over-predicition, under-prediction and for a lack of sharpness
#' @param scores A data.frame of scores based on quantile forecasts as
#' produced by `eval_fcst`, adding a column with regards to train/test set 
#' @param relative_contributions show relative contributions instead of absolute
#' contributions. Default is FALSE and this functionality is not available yet.
#' @return A ggplot2 object showing a contributions from the three components of
#' the weighted interval score for train and test set 

wis.plot <- function(scores, relative_contributions = FALSE){
  
  scores <- data.table::as.data.table(scores)
  
  scores <- data.table::melt(scores,
                             measure.vars = c("overprediction",
                                              "underprediction",
                                              "sharpness"),
                             variable.name = "wis_component_name",
                             value.name = "component_value")
  
  # stack or fill the geom_col position
  col_position <- ifelse(relative_contributions, "fill", "stack")
  
  scores$Set <- factor(scores$Set,  # Reordering group factor levels
                       levels = c("Train", "Test"))
  
  plot <- ggplot2::ggplot(scores, ggplot2::aes_string(x = "model", group = NULL)) +
    ggplot2::geom_col(position = col_position,
                      ggplot2::aes(y = component_value, fill = wis_component_name)) +
    ggplot2::facet_wrap(~ Set, ncol = NULL,
                        scales = "free_y") +
    ggplot2::labs(x = "Model", y = "WIS contributions") +
    ggplot2::theme_light() +
    ggplot2::theme(panel.spacing = ggplot2::unit(4, "mm"),
                   axis.text.x = ggplot2::element_text(angle = 90,
                                                       vjust = 1,
                                                       hjust=1))+
    scale_fill_manual(values=c("#E6A0C4", "#C6CDF7",  "#7294D4")) +
    labs(fill = "WIS component")
  
  return(plot)
}
